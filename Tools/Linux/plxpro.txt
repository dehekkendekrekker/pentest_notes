Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2021-09-30T13:21:50-05:00

====== plxpro ======
Created Thursday 30 September 2021

Binary exploitation toolkit

===== Description =====
plxpro is an exploitation framework that can assist in the exploitation process.

===== Installation =====
{{{code: lang="sh" linenumbers="False"
git clone git@github.com:parall4x/plxpro.git
}}}


===== Dependencies =====
* (python3) pwntools
* (python3) loguru
* gdbserver
* gdb (built with python support)


===== Usage =====
Plxpro can be used to interact with the application and the gdbserver at the same time through a python script.

* Symlink the plxpro directory into your project dir

==== Running with debugger ====
* You'll need to run the rundbg.sh script, to start a socat server that will start the program as a gdb session upon connection.

{{{code: lang="sh" linenumbers="False"
./plxpro/scripts/rundb.sh <binary>
}}}

Any terminal output and input will now be redirected through port 5001. Furthermore, port 8000 will now hold a socket to the gdbserver

=== Template ===
{{{code: lang="python3" linenumbers="False"
plxpro.init(<binary_location>)
plxpro.set_libc(<libc_location>)   # Optional

socket_target = "localhost:5001"     # Select the port you want you need. 5001 will be the terminal input /output
socket_dbg = "localhost:8000"

session = PlxSession(socket_target, socket_dbg, socat=True)

}}}



===== Examples =====

==== Enumerating RIP in case of buffer overflow ====
{{{code: lang="python3" linenumbers="True"
#!/bin/python3
from plxpro import *
from plxpro import enumerator

EXE="./bufof"
TARGET_SOCKET="localhost:5000"
DBG_SOCKET="localhost:8000"

plxpro.init(EXE)

s = PlxSession()
s.connect_target(TARGET_SOCKET)
c_gdb = s.connect_gdb(DBG_SOCKET)

# Initialize RIP enumerator
rip_enum = enumerator.ripoverflow.init(c_gdb)

# Generator a payload used to determine RIP offset
payload = rip_enum.gen_probe(1000)

# Continue debugger
s.cont()

s.send_payload(payload)
# Keep session open. if not, debugger exits
s.interactive()
}}}



==== Enumerating bad bytes ====
{{{code: lang="python3" linenumbers="True"
#!/bin/python3
from plxpro import *
from plxpro import enumerator
import time

EXE="./testprog/badchars"
TARGET_SOCKET="localhost:5000"
DBG_SOCKET="localhost:8000"

plxpro.init(EXE)

def bad_bytes_hook_func(bb_enum : enumerator.badbytes.BadBytes):
    s = PlxSession()
    tgt = s.connect_target(TARGET_SOCKET)
    c_gdb = s.connect_gdb(DBG_SOCKET)

    bp = s.bp("main+264")      # Set break point.
    bb_enum.set_gdb_connection(c_gdb)   # Give enumerator the ability to interact with gdb
    bb_enum.set_breakpoint(bp) # Let enum know to do it's thing when this bp is hit

    payload = bb_enum.get_payload()

    payload += b'A' * 500
    s.send_payload(payload)
    s.cont()
    time.sleep(3)
    tgt.close()

# Initialize BadBytes enumerator
bb_enum = enumerator.badbytes.init()
bb_enum.set_hook_func(bad_bytes_hook_func)
bb_enum.run()


}}}


===== See =====
[[GDB]]

