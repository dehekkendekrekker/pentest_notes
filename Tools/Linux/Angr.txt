Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-03-01T14:57:22-05:00

====== Angr ======
Created Sunday 01 March 2020

Core concepts overview: https://docs.angr.io/core-concepts/toplevel
File system: https://docs.angr.io/advanced-topics/file_system
Optimization: https://docs.angr.io/advanced-topics/speed
Loading: https://github.com/angr/angr-doc/blob/master/docs/loading.md   # Simprocedures
Cheatsheet: https://github.com/angr/angr-doc/blob/master/CHEATSHEET.md

===== The loader =====
loader = proj.loader
proj.loader.all_objects             # All loaded objects
proj.loader.main_object             # The loaded main object (ie, then one specified when loading proj
proj.loader.shared_objects          # Displays loaded shared object. Make sure to load them first ie proj = angr.Project('./vuln1', auto_load_libs=True)
proj.loader.extern_object                    # Here's the "externs object", which we use to provide addresses for unresolved imports and angr internals
proj.loader.kernel_object                    # This object is used to provide addresses for emulated syscalls
proj.loader.find_object_containing(0x400000) # Finally, you can to get a reference to an object given an address in it

proj.loader.shared_objects['libc.so.6'] # Directly get a shared object


==== Getting information about objects ====
obj = loader.main_object
obj.entry # The entry point of the object
obj.min_addr, obj.max_addr  # Min and max address of the object
obj.segments # ELF segments
obj.sections # ELF sections

obj.find_segment_containing(obj.entry)  # Getting the segment containing an address
obj.find_section_containing(obj.entry)  # Getting the section containing an address

addr = obj.plt['strcmp']   # Get the PLT stub of the a function
function = obj.reverse_plt[addr] # Get the function located at an address

# Show the prelinked base of the object and the location it was actually mapped into memory by CLE
>>> obj.linked_base
0x400000
>>> obj.mapped_base
0x400000

==== Dealing with symbols ====
Finding a symbol:

symbol = proj.loader.find_symbol('strcmp')

symbol.name
symbol.owner
symbol.rebased_addr
symbol.linked_addr
symbol.relative_addr (Relative virtual address RVA)

From an owner's point of view
main_strcmp = proj.loader.main_object.get_symbol('strcmp')
main_strcmp.is_import # Is imported? Yes
main_strcmp.is_export # Is imported? No
main_strcmp.resolvedby # In which object is the symbol located?

==== Dealing with imports ====
loader.main_object.imports  # These are the GOT entries after loading up

