Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-02-20T12:13:25-05:00

====== X86 64 ======
Created Thursday 20 February 2020

Function calling convention:

	First Argument: RDI
	Second Argument: RSI
	Third Argument: RDX
	Fourth Argument: RCX
	Fifth Argument: R8
	Sixth Argument: R9

The rest is pushed on the stack


When overwriting RIP:
The address you want to check on is rbp + 8 just  before the function rets.


RBP         :  Framepointer of old stack frame.
RBP + 8 : RIP

First push RIP:                ESP  contains RIP
Second, push RBP         dec ESP,  8. put RBP
Third: move RBP < ESP   RBP contains ESP - 8

So, RBP + 8 = ESP-8+8 = RIP

RBP - 8 : First item on the stack of this frame
--------------------
RBP:          RBP(old)
--------------------
RBP + 8:   RIP
--------------------


Als er meerdere buffer achter elkaar gealloceerd zijn, schrijven de onderste buffers de bovenste over indien kwetsbaar.
Bij het bepalen van de grootte van de payload moet je je de kwetsbare buffer + alle buffers erboven optellen + 8 voor rbp


Sections of a binary file
.bss: https://en.wikipedia.org/wiki/.bss
Holds uninitialized data

===== How malloc works =====
https://danluu.com/malloc-tutorial/
https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/
https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png ← Flowchart of allocation operations

malloc requests heap memory from the kernel by using the sbrk syscall.
Once requested, malloc returns a pointer to the newly created block, but puts a little chunk of metadata right in front of it.
The metadata looks something like this:

TODO : Insert diagram


This means that all blocks are linked.  When a block is freed, the free flag in the struct is set. So next time a malloc call takes  place, 
the chain is traversed in search of a block of the same size. If this is the case, the block is reused. 





