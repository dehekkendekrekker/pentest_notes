Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-04-02T00:48:20-05:00

====== LIBC ======
Created Thursday 02 April 2020


https://sourceware.org/glibc/wiki/MallocInternals
https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/
https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/
https://syedfarazabrar.com/2019-10-12-picoctf-2019-heap-challs/


Security checks:
https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/security_checks.html

TCache related:
http://tukan.farm/2017/07/08/tcache/

Might be useful:
https://medium.com/@c0ngwang/the-art-of-exploiting-heap-overflow-part-7-10a788dd7ab


Allocated chunk

--------------------
8 bytes   | Previous chunk's user data
--------------------
8 bytes   | Chunk Size + |A|M|P
--------------------
X bytes    Data
--------------------
8 bytes   | Size of next chunk
--------------------


--------------------


Free chunk
--------------------
8 bytes   | Chunk Size + |A|M|P
--------------------
8 bytes   | null
--------------------
8 bytes   | Forward pointer

Theres' mor!


===== In a nutshell, malloc works like this: =====

* If there is a suitable (exact match only) chunk in the tcache, it is returned to the caller. No attempt is made to use an available chunk from a larger-sized bin.
* If the request is large enough, mmap() is used to request memory directly from the operating system. Note that the threshold for mmap'ing is dynamic, unless overridden by M_MMAP_THRESHOLD (see mallopt() documentation), and there may be a limit to how many such mappings there can be at one time.
* If the appropriate fastbin has a chunk in it, use that. If additional chunks are available, also pre-fill the tcache.
* If the appropriate smallbin has a chunk in it, use that, possibly pre-filling the tcache here also.
* If the request is "large", take a moment to take everything in the fastbins and move them to the unsorted bin, coalescing them as you go.
* Start taking chunks off the unsorted list, and moving them to small/large bins, coalescing as you go (note that this is the only place in the code that puts chunks into the small/large bins). If a chunk of the right size is seen, use that.
* If the request is "large", search the appropriate large bin, and successively larger bins, until a large-enough chunk is found.
* If we still have chunks in the fastbins (this may happen for "small" requests), consolidate those and repeat the previous two steps.
* Split off part of the "top" chunk, possibly enlarging "top" beforehand. 

For an over-aligned malloc, such as valloc, pvalloc, or memalign, an overly-large chunk is located (using the malloc algorithm above) and divided into two or more chunks in such a way that most of the chunk is now suitably aligned (and returned to the caller), and the excess before and after that portion is returned to the unsorted list to be re-used later. 


===== Free algorithm =====
In a nutshell, free works like this:

* If there is room in the tcache, store the chunk there and return.
* If the chunk is small enough, place it in the appropriate fastbin.
* If the chunk was mmap'd, munmap it.
* See if this chunk is adjacent to another free chunk and coalesce if it is.
* Place the chunk in the unsorted list, unless it's now the "top" chunk.
* If the chunk is large enough, coalesce any fastbins and see if the top chunk is large enough to give some memory back to the system. Note that this step might be deferred, for performance reasons, and happen during a malloc or other call. 


if (have_lock|| 
   ({ assert (locked == 0);  
	 mutex_lock(&av->mutex); 
	 locked = 1;  
	 chunk_at_offset (p, size)->size <= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) >= av->system_mem;
		  }))
	  {
		errstr = "free(): invalid next size (fast)";
		goto errout;
	  }

If you ever get this error:
*** Error in `./chapter1': free(): invalid next size (fast): 0x0000000001f82030 ***

It means that the size of chunk next to the one you want to free() is invalid.
Solution: Try to place a valid size on (addr of error)-0x8 + (size of targt chunk) - 1
The target chunk being the one you want to free. 
You have to substract 1 from the size in memory, as free() does this internally as well. Make sure it aligns on 8 bytes


Malloc and free work FIFO


==== BINS ====
The "bins" are essentially 127 doubly-linked lists. The first one is the unsorted chunks list, then half of the remaining lists are for small bins (one for each 0x10 size), and the rest service large bin requests (with a wider range of size in each bin)


==== Fast bins ====
There are 10 fast bins. Each of these bins maintains a single linked list. Addition and deletion happen from the front of this list (LIFO manner).

Each bin has chunks of the same size. The 10 bins each have chunks of sizes: 16(0x10), 24(0x18), 32(0x20), 40, 48, 56, 64, 72, 80 and 88(0x58). Sizes mentioned here include metadata as well. To store chunks, 4 fewer bytes will be available (on a platform where pointers use 4 bytes). Only the prev_size and size field of this chunk will hold meta data for allocated chunks. prev_size of next contiguous chunk will hold user data.

No two contiguous free fast chunks coalesce together.

Fast bins have a security function that prevents mallocing a block, then overwriting its size and the freeing it using a different size.
This does work with tcache bins.


For instance, malloc has the following check:
- If there is a chunk in the fastbin that can be malloced, check if the size of the location where the chunk will end up is in the same fastbin size
- If not, pass this errror malloc(): memory corruption (fast)


==== Tcache ====
64 bins in total
Sizes: 24 to 1032 bytes on 64-bit systems and 12 to 516 bytes on 32-bit system. Each can have 7 entries

Consolidation does not occur in tcache

Tcache is LIFO

==== Fast bins ====
Fast bins are FIFO
Free chunks are not consolidated

==== Small bins ====
Small bins are FIFO
A small bin has its fd and bk pointer zeroed out upon allocation.

===== Attacks: =====

==== House of Spirit ====

==== House of Force ====
This attacks involves overwriting the top chunk size to be able to malloc an arbitrary address




==== House of Lore ====

==== Fastbin Dup ====

=== * Requirements ===
Double free should be possible

==== Fastbin Dup Consolidate ====

==== Tcache Dup ====

==== Tcache Poisoning ====

==== Tcache House of Spirit ====

==== House of Einherjar ====
https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_einherjar/


- Address leak required


==== Unsafe unlink ====
https://dangokyo.me/2018/01/01/heap-exploitation-unsafe-unlink-fastbin-corruption/

===== Versions =====

==== 2.15 ====

=== Possible attacks: ===
House of Spirit
House of Force
House of Lore
Fastbin Dup
Fastbin Dup Consolidate

==== 2.19 ====

=== Posssible attacks: ===
House of Spirit
House of Force
House of Lore
Fastbin Dup
Fastbin Dup Consolidate

==== 2.23 ====

=== Possbible attacks: ===
House of Spirit
House of Force
House of Lore
Fastbin Dup
Fastbin Dup Consolidate

==== 2.27 ====
Per thread cache got introduced (tchache)

=== Possible attacks: ===
House of Spirit
House of Force
Fastbin Dup
Fastbin Dup Consolidate
Tcache Dup
Tcache Poisoning
Tcache House of Spirit

==== 2.29 ====

=== Possible attacks: ===
House of Spirit
Tcache Poisoning
Tcache House of Spirit


====== Functions ======

==== sscanf ====
Adds \0 when using %s modifier


